---
description: safe relay kit and pimlico api key integration
globs: 
alwaysApply: false
---
 codex
    Below is a deep‑dive, end‑to‑end spec for wiring in a “gasless” Safe‑deployment flow via Pimlico in your
    create-safe/page.tsx.  It is written so you can hand it off directly to another AI or engineer and have
    them implement everything without missing steps.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

        1. OVERVIEW
           ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    Goal: when a user clicks Deploy Primary Safe on Base, we will

        1. Build the Safe‐deployment transaction on the client (using `@safe-global/protocol-kit`)
        2. Send it **gas‑free** to a Pimlico relayer (they pay the gas)
        3. Poll a public RPC for confirmation
        4. Persist the newly deployed Safe address via your existing tRPC `completeOnboarding` mutation
        5. Invalidate your stale queries so UI updates

    No new smart contracts.  No new server endpoints.  A small, self‐contained client adapter layer.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    2) PREREQUISITES
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    A) ENVIRONMENT VARIABLES (in .env.local / Vercel dashboard)
     • NEXT_PUBLIC_PIMLICO_API_KEY
     • NEXT_PUBLIC_BASE_RPC_URL  (for polling receipts, e.g. your Alchemy/Infura URL)

    B) NPM DEPENDENCIES
     • Already installed:
       – @safe-global/protocol-kit
       – viem
     • No additional packages required (we’ll use built‑in fetch).

    C) FILES TO MODIFY / ADD

        1. `packages/web/src/lib/safe-relayer.ts` – Define the interface + factory
        2. `packages/web/src/lib/pimlico-relayer.ts` – Pimlico implementation
        3. `packages/web/src/app/onboarding/create-safe/page.tsx` – Replace direct `sendTransaction` with
    relayer flow
        4. (Optionally) update `tsconfig.json` if needed to include `src/lib` path aliases

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    3) SAFE-RELAYER INTERFACE & FACTORY
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    File: packages/web/src/lib/safe-relayer.ts

        // src/lib/safe-relayer.ts

        /** 
         * Abstracts over any "gasless" relay you plug in.
         */
        export interface SafeRelayer {
          /**
           * Sponsor a Safe deployment or Safe transaction.
           * 
           * @param chainId     EIP‑155 chain id (e.g. 8453 for Base)
           * @param to          contract address (factory or safe)
           * @param value       native value in wei as string
           * @param data        full calldata hex string (0x…)
           * @param userAddress EOA address (for indexing / attribution)
           * @returns           the sponsor’s txHash on chain
           */
          relayTx(params: {
            chainId: number
            to: string
            value: string
            data: string
            userAddress: string
          }): Promise<string>
        }

        /**
         * Factory: choose your relayer implementation here.
         * Today: Pimlico only. In future: swap in SafeKitRelayer etc.
         */
        export function getRelayer(): SafeRelayer {
          const { PimlicoRelayer } = require('./pimlico-relayer')
          const apiKey = process.env.NEXT_PUBLIC_PIMLICO_API_KEY
          if (!apiKey) throw new Error('NEXT_PUBLIC_PIMLICO_API_KEY is not set')
          return new PimlicoRelayer(apiKey)
        }

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    4) PIMLICO-RELAYER IMPLEMENTATION
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    File: packages/web/src/lib/pimlico-relayer.ts

        // src/lib/pimlico-relayer.ts

        import type { SafeRelayer } from './safe-relayer'

        const DEFAULT_PIMLICO_URL = 'https://api.pimlico.io/v1/relay/sponsor'

        export class PimlicoRelayer implements SafeRelayer {
          private apiKey: string
          private endpoint: string

          /**
           * @param apiKey    process.env.NEXT_PUBLIC_PIMLICO_API_KEY
           * @param endpoint  optional override of Pimlico URL
           */
          constructor(apiKey: string, endpoint?: string) {
            if (!apiKey) throw new Error('Pimlico API key missing')
            this.apiKey = apiKey
            this.endpoint = endpoint ?? DEFAULT_PIMLICO_URL
          }

          async relayTx(params: {
            chainId: number
            to: string
            value: string
            data: string
            userAddress: string
          }): Promise<string> {
            // Construct the request payload
            const body = {
              network: params.chainId,
              target: params.to,
              data: params.data,
              value: params.value,
              user: params.userAddress,
            }

            // Fire the HTTP request
            const res = await fetch(this.endpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.apiKey}`,
              },
              body: JSON.stringify(body),
            })

            // Handle errors
            if (!res.ok) {
              let errMsg: string
              try {
                const errJson = await res.json()
                errMsg = errJson.error || errJson.message || JSON.stringify(errJson)
              } catch {
                errMsg = res.statusText
              }
              throw new Error(`Pimlico relay failed: ${errMsg}`)
            }

            // Parse success
            const json = await res.json()
            if (!json.txHash) {
              throw new Error(`Pimlico response missing txHash: ${JSON.stringify(json)}`)
            }
            return json.txHash as string
          }
        }

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    5) MODIFY create-safe/page.tsx
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    A) ADD IMPORTS at top:

        import { getRelayer } from '@/lib/safe-relayer'
        import { createPublicClient, http } from 'viem'

    B) INSIDE handleCreateSafe(), replace the “send deployment tx” block.  Find:

        // 5. Prepare viem clients for sending transaction
        const walletClient = createWalletClient({ … })

        // 6. Send the deployment transaction
        const txHash = await walletClient.sendTransaction({ … })
        … wait…
        const txReceipt = await walletClient.waitForTransactionReceipt({ hash: txHash });

    DELETE those lines, and INSERT:

        // 5. Sponsor deployment via Pimlico (gasless)
        const relayer = getRelayer()
        const txHash = await relayer.relayTx({
          chainId: base.id,
          to: safeDeploymentTransaction.to as string,
          value: safeDeploymentTransaction.value.toString(),
          data: safeDeploymentTransaction.data as string,
          userAddress,
        })
        console.log(`0xHypr - Pimlico txHash: ${txHash}`)

        // 6. Wait for on‑chain confirmation via public RPC
        const publicClient = createPublicClient({
          chain: base,
          transport: http(process.env.NEXT_PUBLIC_BASE_RPC_URL!),
        })
        console.log(`0xHypr - Waiting for receipt of ${txHash}`)
        await publicClient.waitForTransactionReceipt({ hash: txHash })
        console.log(`0xHypr - Received receipt for ${txHash}`)

    C) AFTER confirmation, continue (predicted address = deployed address).
    No change to your tRPC completeOnboardingMutation call or cache invalidation.

    D) UPDATE LOADING & ERROR MESSAGES:
    • Button text → “Sponsoring Safe deployment…”
    • Error messaging on relay failure vs. chain‑switch vs. SDK init

    E) FULL SNIPPET of new handleCreateSafe (condensed):

        async function handleCreateSafe() {
          // ...chain switch + provider setup...
          const protocolKit = await Safe.init({ predictedSafe: { safeAccountConfig, safeDeploymentConfig },
    provider })
          const safeDeploymentTransaction = await protocolKit.createSafeDeploymentTransaction()
          const predictedSafeAddress = await protocolKit.getAddress()

          // Sponsor via Pimlico
          const relayer = getRelayer()
          let txHash: string
          try {
            txHash = await relayer.relayTx({
              chainId: base.id,
              to: safeDeploymentTransaction.to as string,
              value: safeDeploymentTransaction.value.toString(),
              data: safeDeploymentTransaction.data as string,
              userAddress,
            })
          } catch (relayErr: any) {
            console.error('Relay error:', relayErr)
            setDeploymentError(`Failed to sponsor deployment: ${relayErr.message}`)
            setIsLoading(false)
            return
          }

          // Wait for confirmation
          const publicClient = createPublicClient({
            chain: base,
            transport: http(process.env.NEXT_PUBLIC_BASE_RPC_URL!),
          })
          try {
            await publicClient.waitForTransactionReceipt({ hash: txHash })
          } catch (receiptErr: any) {
            console.error('Receipt error:', receiptErr)
            setDeploymentError(`Transaction ${txHash} not confirmed: ${receiptErr.message}`)
            setIsLoading(false)
            return
          }

          // Success path: record Safe address
          setDeployedSafeAddress(predictedSafeAddress)
          try {
            await completeOnboardingMutation.mutateAsync({ primarySafeAddress: predictedSafeAddress })
            utils.settings.userSafes.list.invalidate()
            utils.onboarding.getOnboardingStatus.invalidate()
          } catch (trpcErr: any) {
            console.error('tRPC save error:', trpcErr)
            setDeploymentError(`Safe created (${predictedSafeAddress}), but failed to save profile.`)
          } finally {
            setIsLoading(false)
          }
        }

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    6) TRPC / SERVER SIDE
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    • No new endpoints required.
    • You continue using onboardingRouter.completeOnboarding to persist the Safe.
    • All transaction‐sponsorship happens entirely client‑side via Pimlico.
    • Your safeRouter stays unchanged.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    7) ERROR HANDLING & LOGGING
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    • Chain‑switch errors: catch separately, show “Please switch to Base.”
    • Safe SDK errors: e.g. init, createSafeDeploymentTransaction, show generic “An unknown error occurred
    during deployment.”
    • Relay errors: surface Error.message from Pimlico adapter.
    • Receipt errors: show “Transaction not confirmed” with hash.
    • tRPC errors: show “Failed to save Safe address.”
    • Always console.error(...) for rich logs.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    8) TEST PLAN
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

        1. **Unit**: mock `Safe.init/createSafeDeploymentTransaction` → ensure `relayTx` is invoked with
    correct args.
        2. **Integration**: in dev, set `NEXT_PUBLIC_PIMLICO_API_KEY` to a real key, supply some Base ETH to
    Pimlico test account → click “Deploy Primary Safe” → watch Pimlico dashboard + block explorer.
        3. **Error**: revoke the API key or set an invalid one → click button → ensure relay error is caught
    and shown.
        4. **tRPC**: verify after confirmation, `userProfilesTable` and `userSafes` have new Safe address.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    9) FUTURE SWAP‑IN: YOUR OWN PAYMASTER
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

        1. Write `SafeKitRelayer implements SafeRelayer` in `src/lib/safe-kit-relayer.ts`, e.g.:

               import { RelayKit } from '@safe-global/relay-kit'
               import Safe from '@safe-global/protocol-kit'

               export class SafeKitRelayer implements SafeRelayer {
                 private relay: RelayKit
                 constructor(config: { paymasterAddress: string; rpcUrl: string }) {
                   this.relay = new RelayKit({ paymasterAddress: config.paymasterAddress, chainId: 8453,
    rpcUrl: config.rpcUrl })
                 }
                 async relayTx({ to, data, value, userAddress }: any): Promise<string> {
                   // Build and send a userOp or Safe transaction
                   // ...
                 }
               }
        2. In `getRelayer()`, switch based on `process.env.NEXT_PUBLIC_RELAYER === 'safekit'`.
        3. No changes anywhere else.

    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    10) HAND‑OFF CHECKLIST
    ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    ❏ Create src/lib/safe-relayer.ts and src/lib/pimlico-relayer.ts exactly as above.
    ❏ Update src/app/onboarding/create-safe/page.tsx with imports and diffed logic.
    ❏ Verify env vars are present.
    ❏ Run local dev and click “Deploy Primary Safe” end‑to‑end.
    ❏ Confirm DB update via tRPC mutation.
    ❏ Add unit and integration tests around the new adapter.

    Once complete, you’ll have a robust, fully‑gasless onboarding flow that can later be repointed to your own
     Paymaster or Safe RelayKit without touching any UI code.lri